<!DOCTYPE html><html><head><link rel="stylesheet" href="style.css"/>
    <title>towards_spiritstream</title></head><body><p><a href="index.html">Index</a></p><br><p>TL;DR: The Spiritstream seeks to expand the limit of mind-machine coherence through a deeply simple and powerful interface to see deeper into the unknown. Assumption is that there is more than bandwidth (BCI) to solve and that new and interesting spaces await.</p><br><p><a href="https://github.com/lorinbaum/spiritstream">This repo</a> is where I built. </p><h1 id="towards-spiritstream">Towards Spiritstream</h1><toc><ul><li><a href="towards_spiritstream.html#how-to-merge-">How to merge?<br></a></li><li><a href="towards_spiritstream.html#should-i-try-and-build-a-neural-interface-">Should I try and build a neural interface?<br></a></li><li><a href="towards_spiritstream.html#less-refined-i">Less refined I<br></a><ul><li><a href="towards_spiritstream.html#server">Server<br></a></li><li><a href="towards_spiritstream.html#-popups-">"Popups"<br></a></li><li><a href="towards_spiritstream.html#encrypted-backup">Encrypted backup<br></a></li></ul></li></ul></toc><br><p>Following curiosity and leaning into my wonder about computers and internet, I sense dissolution: The edges of my body fade and I float through the associations between all possible spaces. Into the space, through trees, stories, videogames, temples, beauty, destruction. I see my questions answered, not definitively, but as completely as the collective mind can. I sense connection, trusting and deep. I sense the conflicts in the world as internal, not as foggy, distant pain. I stream into others to see exactly what they mean. And in my action, the structure of the world, not merely my individual life, is reflected.<br>Returning to my body, I can't help but wonder what the fuck this is: Me, stopping with my fingertips, unable to walk through walls, facing the endless world in mist asking hello with no answer.</p><br><p><img src="/mnt/witchcraft/synched/code/spiritstream/output/creative_destruction_2.1.jpg" /></p><blockquote>Spirit of curiosity</blockquote><br><p>There seems to be a structure behind notes, memes, essays, books, stories, exhibitions, spaces, products, worlds. They consists of simple patterns in the mind, their process might be reflected like this: </p><br><blockquote>Sense, explore, parse circling patterns from<br>chaotic and far-reaching,<br>through filtered and coherent knowledge,<br>to linearized, actionable and accessible stories.<br><br>Express to reinvoke, refine and spread the patterns<br>in process,<br>from memory.<br><br>Share in truth,<br>to test, be surprised, dance, reproduce, join the cutting edge, offer, cohere, support, punish,<br>into common languages per context,<br>into scopes of recipients,<br>under optional conditions.<br><br>Where I am,<br>When I am.</blockquote><br><p>If the process can be reflected in the machine, the patterns and me with them can enter the machine and then its abilities...</p><br><blockquote>Receive from any electric sensor<br><br>Run programs compiled from many languages,<br>from and to memory<br><br>Store, share and retrieve quickly and persistently<br><br>Express in any electric actuator, speaker, display.</blockquote><br><p>...become my own. The spiritstream aims to be the passage into the machine.</p><h2 id="how-to-merge-">How to merge?</h2><p>Since I construct meaning from the individual, I view all higher structures of power (groups, communes, cities, states, religions) as services to the individual. Build free, accessible, independent, private, no login, no lock in.</p><br><p>Inspired by Obsidian and <a href="https://twitter.com/karpathy/status/1751350002281300461">Karpathy's ideal blogging platform</a>, a WYSIWYG markdown editor seemed like a reasonable choice. Written language works surprisingly well to represent complex ideas and stories and there is an unassuming simplicity about a book as merely a holder of a long string of words. Markdown's basic formatting options and linking and embedding other files should provide plenty of differentiation options even for the most vague thoughts. Markdown is easily readable in raw text. It is trivial to learn and to convert to HTML for display in any web browser. It even supports inline HTML for special formatting. It is frequently used and well understood by LLMs, providing an opportunity for seamless integration.</p><br><p>While implementing this editor, I met some limitations that made me question the markdown paradigm.</p><ul><li>To provide a visual interface, a different paradigm may be necessary. The highest quality interfaces require molding to the user at high resolution. My ideas about staying in the markdown paradigm, using "popups" and "control mostly using keyboard shortcuts" seem clunky. Switching to a different paradigm for UI that allows arbitarily placed buttons, tooltips, menus and input fields, feels like introducing magic, top down by the programmer to the unempowered user.</li></ul><p>Some technical challenges, though certainly solvable with more code, still weigh on me with their complexity, revealing markdown's limitations instead of deeper truths.</p><ul><li>Parsing markdown is surprisingly complicated, e.g. it allows both <code>*</code> and <code>_</code> for both bold and italic emphasis, leading to CommonMark defining 17 rules to disambiguate this syntax.</li><li>For WYSIWYG, the formatting text is hidden by default and appears only if the cursor is inside the corresponding element. When clicking on an image, this leads to "jitter" as the link it suddenly has to insert itself to become editable.</li><li>Performant text updates depend on keeping updated portions to a minimum. In a markdown editor, this is non-trivial as text edits may affect formatting of a whole section, or in the case of the fenced code block syntax, the whole document.</li></ul><br><p>More generally, I find myself trying to identify and question my assumptions:</p><ul><li>HTML output</li><li>Pure hierarchy (HTML)</li><li>Responsive design for different devices (HTML)</li><li>BLOCK/INLINE (HTML)</li><li>Semantic blocks / blocks for identification by css (HTML)</li><li>css for styling (HTML)</li><li>Markdown and other text based operation for compatibility, human-readability and easier interface</li><li>2D interface because 3D too complicated to both understand and manage through the interface</li><li>UI should be built from the same pieces as the user created patterns</li></ul><br><p>Goals:</p><ul><li>MEMORY: Put down mixed media (images, video, sound, text, painting) to capture patterns for later reference and further processing. From scratch or from other people.</li><li>SHARE: Share some portions to some group on optional conditions.</li><li>AVAILABILITY: Phone, online, anywhere, anytime, no login to a service.</li><li>PROGRAMS and OUTPUT: Use the data in the spiritstream for arbitrary programs</li></ul><br><ol><li>HTML output: NO! No restriction from existing formats. Compile to WASM for sharing. The goal is experimentation not compatibility.</li><li>Pure Hierarchy NO: In case of ambiguity, resolve ownership by using highest security level found in affected area. Adds complexity to allow more intuitive, though chaotic "graphical" editing, where its more like painting, which is intuitively understood as a series of brush strokes, not some individual pixels changing appearance. Strict hierarchy is a distortion of the user actions, which may sweep over categories and parts of categories (highlighting, italic). Use order in which they were created to choose between conflicting overlapping styles.</li><li>Responsive design: YES to ensure availability anywhere, even on new/foreign devices. Although ergonomic text is narrow anyway and should fit most devices.</li><li>BLOCK /INLINE: NO! defined width means atomic (can't split) and all elements flow horizontally.</li><li>Semantic blocks: OPTIONAL can use an LLM to infer or set manually if high resolution is desired. It's nice for quick parsing, but should not be explicitly needed.</li><li>CSS for styling.</li><li>Markdown/textbased: text based unifies the whole API which also makes it more human readable. Just need a way to translate in a nice manner. Fundamentally necessitates escape sequences, so the characters to escape should be few.</li></ol><br><p>Learnings about fundamental problems in text editors:</p><ul><li>3 parts:<br><ul><li>parsing and serializing node graph</li><li>modifying the node graph</li><li>interface for displaying and editing</li></ul></li><li>On rendering, the formatting is determined, the text is grabbed and placed in sequence at a given location. In a line wrap, line height is used to determine position of the next characters (images), in a block element, margin / padding are used.</li><li>images are rendered like large glyphs</li></ul><br><p>Future editor:</p><ul><li>Synchronize with untrusted remote servers. Public data available in web view.</li><li>Algorithms same power as humans: Server - client model</li><li>Complexity appears when looked for. Should be simple, functional editor unless user decides to explore.</li><li>To be become scary, serious and more real, therefore adventurous, payment must be supported. And later an interface to robots. </li><li>Functionality beyond pure basics, like calendar, todo list, AI integration, social media backends, payments, crypto, exporters, interpreters, robot APIs is done through plugins. Base spirit stream provides only base API for functionality and UI. All UI uses the basic API and can be rebuilt. </li><li>Spirit stream can be viewed through lens of any contact.</li><li>BACK and FORWARD buttons to step through navigation history. </li><li>reimplementing spirit stream in another language should be trivial.</li></ul><br><h2 id="should-i-try-and-build-a-neural-interface-">Should I try and build a neural interface?</h2><p>The flow of patterns in the mind precedes common language and translating them shrinks and distorts them. A direct neural interface may simplify the process. An AI could interpret the stream and seamlessly induce useful patterns.<br>The patterns are repetitive and I have seen myself expressed in words almost entirely. Simple words or images can speak so loudly and clearly, throwing open the doors to the world with their precision and closeness. Finally, the problem of organizing symbols - patterns or words - remains. The neural interface may follow.</p><h2 id="less-refined-i">Less refined I</h2><p>Snapshots for version history are a view on the node graph, which references prior versions.</p><br><p>Navigation history / pinned UI with quick links can help navigate faster</p><br><p>Actions:</p><ul><li>list all scenes / frames and it will include those that are not normally linked to.</li><li>list snapshots of this file</li><li>make new snapshot</li><li>export</li><li>export(target, live, relay)</li></ul><br><p>Leftover thoughts from previous spec:</p><ul><li>Links GO / SHOW</li><li>Valid targets are headings, files or URLs. Files that can't be opened natively offer system default or custom external program.</li><li>Delete is the same as removing all references to a piece of data, gives warning when deleting last reference.</li><li>Can fuzzy search node names or search nodes by overlapping links, prioritizing deeper nodes.</li><li>Undo history is a graph</li><li>Clicking on any past state restores it, but only modifying it, updates it to the be the newest version. History nodes are like links so they can be opened in a new tab/side by side</li><li>node may point to previous version of itself. referencing the current head of the tree enough. can store only deleted nodes to history, so the current ones are always accessible.</li><li>Client handles interface. Server does functionality. Even when running locally, theres a server. Run without client for seamless remote hosting. Client trusts the server as little as possible. Maybe client comes with its own API like a plugin to the server. </li></ul><br><ul><li><a href="https://stephango.com/file-over-app">file over app</a></li><li>discord</li><li>atom/rss</li><li><a href="https://powerdns.org/">PowerDNS.org with articles</a></li></ul><br><ul><li>Who knows what and how people want to edit. Best editor is a tool to build your own editor?</li><li>a language model that has not learned to answer questions tells stories</li></ul><br><p>Slider for speed / memory tradeoff for whole computer.</p><br><p>This appears like an infinite journey which means urgency. the sooner the client, the sooner the OS, the robots, the hardware, raw materials.</p><br><p>Computers open infinite possibilities and all software exists to limit the possibilities to an understandable set of useful actions. I fail to understand how to set those boundaries.<br>Functions keep the underlying possibilities but now open paths to more easily do something new at the cost of introducing a new function.<br>The task is to identify a small set of functions that can still do a lot.<br>Markdown is literally that and has emergent uses because of it.<br>Layers appear where a single layer may do <i>all</i> the things needed by the user, but if not, a deeper layer offers more options. it is not new, it already builds the known layer, but could build other layers too.</p><br><p>Maybe build more things that are fun and figure out abstractions on the way. This whole thing is self propelled: most of what I post here is related to the thing behind posting itself.</p><h3 id="server">Server</h3><p><b>host</b>(directory, port, password=None, ssl=None)<br>Creates a server instance. If password is None, access via localhost is assumed, communication on HTTP is opened for efficiency and a token is generated that any api call must include. If a password is provided, HTTPS is enabled and ssl certificate becomes required.</p><br><p><b>connect</b>(address, port, password=None, ssl=None)<br>Opens a connection using the password to authenticate on the server and loading the ssl keys for any future calls. Can connect without password in case of HTTP on localhost and the server is configured appropriately.</p><br><p><b>sync</b>(files="all")</p><br><p><b>pull_events</b><br>to update client if someone else caused an event</p><br><p><b>write</b><br><b>erase</b></p><br><p><b>frame</b>(x,y,w,h,style,privacy,name) -> Node</p><br><p><b>save</b><br>syncs to server which writes to disk.</p><br><p>To fix:</p><ul><li>speed</li><li>rising memory usage</li><li>backslash escape</li></ul><h3 id="-popups-">"Popups"</h3><p>"popups" are new frames with class "ephemeral" that are processed on <code>Ctrl+S</code> (Save) or on some link with a particular class pressed.</p><br><p><code>Ctrl+I</code> for information on current frame. A codeblock with key value. For used css and permissions?</p><h3 id="encrypted-backup">Encrypted backup</h3><p><code>Ctrl+E</code> to export current file.<br><code>Ctrl+Shift+E</code> export all connected files.</p><br><p>In popup, shows all files that are public, all backed up and private as links.</p><br><p>Can also globally be changed there by shifting them around. into their categories under corresponding headings.</p><br><p>It indicates relative status to remote: "new", "deleted", "modified".<br>Export target put into key-value pair in codeblock. <br>Can be path or user@domain for ssh. In case of SSH, it prompts for the password as well after confirming. Just paste (will not show) and confirm (save), then prints logs and next save will close the popup (return to previous with exact view).</p><br><p>Later: files to be backed up, are padded and supplied with a header:<br><code>version</code>, <code>filename</code>, <code>padding size</code>, <code>hash</code>.<br>The file has a uuid(4) (for random and unique across systems) as ID, this + base key to derive unique encryption key. rename to UUID and encrypt name + content.<br>When retrieving use encrypted UUID to get file. Verify integrity by hashing the decrypted file and comparing with head hash.<br>The UUID map has an ID of "index". It is never stored decrypted is also backed up. Server auth and base key and "index" is enough to access all data that sits on the server from anywhere.</p><br><p>Messages are updates that are downloaded like everything else. Signal, WhatsApp and other backends. Chats are frames linked to using <code>#end</code> and the text flows upwards?</p><br><p>snapshots are separate files. Like <code>Ctrl+Shift+S</code> to snapshot current file.<br>If embedded stuff has changed too, store a snapshot of that as well and replace links to reference that snapshot. soon becomes a snapshot of the entire site to maintain accurate references later.<br>If only this frame matters, realize embeds and ignore external links.</p><br><p><code>live</code> is an export option, in which case it will look to open a UDP connection to the target for audio/video calls.<br>specify <code>relay</code> address to which I stream and from which it is then distributed.<br>To ensure available bandwidth on servers with limitations, add cost information to host.<br>Be transparent about bandwidth used for what purpose and transmission at any time.</p><br><p>files that are not natively supported in spiritstream can still be openend and a message will inform, then settings can still be changed, like privacy.</p><br><ul><li>Knowledge appears so simple, so efficiently encoded. How to make rice. Explaining in enitrety, I require too many words to even approximate. How to know?</li></ul></html>